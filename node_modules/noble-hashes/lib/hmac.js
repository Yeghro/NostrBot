"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = void 0;
const utils_1 = require("./utils");
// HMAC (RFC 2104)
class HMAC extends utils_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        (0, utils_1.assertHash)(hash);
        const key = (0, utils_1.toBytes)(_key);
        this.iHash = hash.create();
        if (!(this.iHash instanceof utils_1.Hash))
            throw new TypeError('Expected instance of class which extends utils.Hash');
        const blockLen = (this.blockLen = this.iHash.blockLen);
        this.outputLen = this.iHash.outputLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        this.iHash.update(buf);
        return this;
    }
    _writeDigest(out) {
        if (this.finished)
            throw new Error('digest() was already called');
        this.finished = true;
        this.iHash._writeDigest(out);
        this.oHash.update(out);
        this.oHash._writeDigest(out);
        this._clean();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this._writeDigest(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    _clean() {
        this.oHash._clean();
        this.iHash._clean();
    }
}
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
exports.hmac.init = exports.hmac.create;
